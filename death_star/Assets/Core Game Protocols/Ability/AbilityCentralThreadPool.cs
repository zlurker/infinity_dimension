using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;

public enum NETWORK_CLIENT_ELIGIBILITY {
    GRANTED, DENIED, LOCAL_HOST
}

public class AbilityNodeNetworkData<T> : AbilityNodeNetworkData {

    public T value;

    public AbilityNodeNetworkData(int nId, int vId, T v) {
        nodeId = nId;
        varId = vId;
        value = v;

        dataType = typeof(T);
    }
}

public class AbilityNodeNetworkData {
    public int nodeId;
    public int varId;
    public Type dataType;
}

public class NodeThread {

    int currNode;
    int startingPt;

    // To be used for creation of new threads when it branches out.
    // generatedNodeTheads/possiblePaths.       
    protected int generatedNodeThreads;
    protected int possiblePaths;

    public NodeThread(int sPt) {

        startingPt = sPt;
        currNode = -1;
    }

    public int GetStartingPoint() {
        return startingPt;
    }

    public void SetNodeData(int cN, int pS) {
        currNode = cN;
        SetPossiblePaths(pS);
    }

    public void SetPossiblePaths(int pS) {
        generatedNodeThreads = 0;
        possiblePaths = pS;
    }

    public int GetCurrentNodeID() {
        return currNode;
    }

    public int GetPossiblePaths() {
        return possiblePaths;
    }

    public virtual NodeThread CreateNewThread() {
        generatedNodeThreads++;

        if(possiblePaths > generatedNodeThreads)
            return new NodeThread(startingPt);

        return null;
    }
}

public class NodeInstanceData {

}

public class AbilityCentralThreadPool : NetworkObject, IRPGeneric, ITimerCallback {

    public static EnhancedList<AbilityCentralThreadPool> globalCentralList = new EnhancedList<AbilityCentralThreadPool>();
    public static EnhancedList<List<int>> globalCentralClusterList = new EnhancedList<List<int>>();

    public AbilityCentralThreadPool() {
        playerCasted = 0;
        InitialiseCentralVariables();
    }

    public AbilityCentralThreadPool(int pId) {
        playerCasted = pId;
        InitialiseCentralVariables();
    }

    void InitialiseCentralVariables() {
        networkNodeData = new Dictionary<int, List<AbilityNodeNetworkData>>();
        activeThreads = new EnhancedList<NodeThread>();
        timerEventId = -1;
        networkObjectId = -1;
        instId = -1;
    }

    private Variable[][] runtimeParameters;
    private Type[] subclassTypes;
    private Transform abilityNodeRoot;
    private AbilityTreeNode[] nodes;

    private int[] nodeBranchingData;

    //private AbilityBooleanData booleanData;
    private bool[][] booleanData;

    private int[][] autoManagedVar;

    private int playerCasted;

    // This thread's ID
    private int centralId;

    private int timerEventId;

    private Dictionary<int, List<AbilityNodeNetworkData>> networkNodeData;

    private Dictionary<Tuple<int, int>, HashSet<Tuple<int, int>>> onChanged;
    //private Dictionary<Tuple<int, int>, HashSet<int>> onVarCalled;
    //private Dictionary<int, HashSet<Tuple<int, int>>> onGet;

    private Dictionary<int, HashSet<Tuple<int, int>>> sharedInstance;

    // 1st tuple for target node/var, 2nd for types for this target, 3rd for 
    // This is generated by Manager.
    private Dictionary<Tuple<int, int>, Dictionary<Type, HashSet<int>>> targettedNodes;

    //private Dictionary<int,<Tuple<int,int>>>

    private int centralClusterId;
    private int clusterPos;

    //private List<AbilityNodeNetworkData> networkNodeData;

    // Current threads active
    private EnhancedList<NodeThread> activeThreads;

    #region Network-Related Code
    private int networkObjectId;
    private int instId;

    public void NetworkObjectCreationCallback(int networkObjId, int iId) {
        networkObjectId = networkObjId;
        instId = iId;
    }

    public int ReturnNetworkObjectId() {
        return networkObjectId;
    }

    public int ReturnInstId() {
        return instId;
    }
    #endregion

    public AbilityTreeNode GetNode(int id) {
        return CreateNewNodeIfNull(id);
    }

    public Transform GetAbilityRoot() {
        return abilityNodeRoot;
    }

    // Base method to get variables.
    public Variable ReturnVariable(int node, int variable) {

        if(CheckIfReferenced(node, variable))
            return GetRootReferenceCentral(node).ReturnVariable(nodes[node].GetReference().Item2, variable);

        return runtimeParameters[node][variable];
    }

    public Variable ReturnVariable(int node, string vName) {
        int variable = LoadedData.loadedParamInstances[subclassTypes[node]].variableAddresses[vName];
        return ReturnVariable(node, variable);
    }

    public RuntimeParameters<T> ReturnRuntimeParameter<T>(int node, string vName) {
        int variable = LoadedData.loadedParamInstances[subclassTypes[node]].variableAddresses[vName];
        return ReturnVariable(node, variable).field as RuntimeParameters<T>;
    }

    public RuntimeParameters<T> ReturnRuntimeParameter<T>(int node, int variable) {
        return ReturnVariable(node, variable).field as RuntimeParameters<T>;
    }

    public int ReturnCentralId() {
        return centralId;
    }

    public void SetCentralData(int tId, Variable[][] rP, Type[] sT, int[] nBD, bool[][] aBD, int[][] amVar, int cId, Dictionary<Tuple<int, int>, Dictionary<Type, HashSet<int>>> oVC) {

        abilityNodeRoot = new GameObject(tId.ToString()).transform;
        //Debug.Log("Ability created.");

        centralId = tId;
        runtimeParameters = rP;
        subclassTypes = sT;
        nodeBranchingData = nBD;
        booleanData = aBD;
        autoManagedVar = amVar;
        centralClusterId = cId;
        nodes = new AbilityTreeNode[rP.Length];

        onChanged = new Dictionary<Tuple<int, int>, HashSet<Tuple<int, int>>>();


        targettedNodes = new Dictionary<Tuple<int, int>, Dictionary<Type, HashSet<int>>>(oVC);
        //Debug.Log("OVC Count: " + oVC.Count);

        //foreach(var key in onVarCalled.Keys) {
        //Debug.Log(key);
        //}
        //onGet = new Dictionary<Tuple<int, int>, HashSet<Tuple<int, int>>>();
        sharedInstance = new Dictionary<int, HashSet<Tuple<int, int>>>();
    }

    public bool AddOnChanged(Tuple<int, int> key, Tuple<int, int> value) {

        if(!onChanged.ContainsKey(key))
            onChanged.Add(key, new HashSet<Tuple<int, int>>());

        if(!onChanged[key].Contains(value)) {
            onChanged[key].Add(value);
            return true;
        }

        return false;
    }

    public void AddSharedInstance(int key, Tuple<int, int> value) {
        if(!sharedInstance.ContainsKey(key))
            sharedInstance.Add(key, new HashSet<Tuple<int, int>>());

        if(!sharedInstance[key].Contains(value))
            sharedInstance[key].Add(value);
    }

    public void RemoveSharedInstance(int key, Tuple<int, int> value) {
        if(sharedInstance.ContainsKey(key))
            if(sharedInstance[key].Contains(value))
                sharedInstance[key].Remove(value);
    }

    public int GetNodeBranchData(int id) {
        return nodeBranchingData[id];
    }

    public int GetNewThread(int startNode) {
        return activeThreads.Add(new NodeThread(startNode));
    }

    public bool[] GetNodeBoolValues(int id) {
        return booleanData[id];
    }

    public void SetNodeBoolValue(bool value, int node, int var) {
        booleanData[node][var] = value;
    }

    public int GetClusterID() {
        return centralClusterId;
    }

    public int GetPlayerId() {
        return playerCasted;
    }

    public int AddNewThread(NodeThread inst) {
        return activeThreads.Add(inst);
    }

    public NodeThread GetActiveThread(int threadId) {
        return activeThreads.l[threadId];
    }

    public void SetTimerEventID(int id) {
        timerEventId = id;
    }

    public void AddVariableNetworkData(AbilityNodeNetworkData aNND) {
        //Debug.Log("Variable Data added.");

        if(timerEventId > -1) {
            //Debug.Log("Timer extended.");
            LoadedData.GetSingleton<Timer>().UpdateEventStartTime(timerEventId, Time.realtimeSinceStartup);
        } else {
            //Debug.Log("New timer added.");
            timerEventId = LoadedData.GetSingleton<Timer>().CreateNewTimerEvent(0.05f, this);
            networkNodeData.Add(timerEventId, new List<AbilityNodeNetworkData>());
        }

        networkNodeData[timerEventId].Add(aNND);
    }

    public void CallOnTimerEnd(int eventId) {
        UpdateAbilityDataEncoder encoder = NetworkMessageEncoder.encoders[(int)NetworkEncoderTypes.UPDATE_ABILITY_DATA] as UpdateAbilityDataEncoder;
        //Debug.Log("Send data worth " + networkNodeData.Count);

        AbilityNodeNetworkData[] data = networkNodeData[eventId].ToArray();
        networkNodeData.Remove(eventId);

        encoder.SendVariableManifest(this, data);

        if(timerEventId == eventId)
            timerEventId = -1;
    }

    public void StartThreads() {
        int lastNodeId = runtimeParameters.Length - 1;
        int threadId = GetNewThread(lastNodeId);

        activeThreads.l[threadId].SetNodeData(lastNodeId, nodeBranchingData[lastNodeId]);
        NodeVariableCallback<int>(threadId, 0);
    }

    public bool CheckIfReferenced(int nodeId, int variableId) {
        if(nodes[nodeId] == null)
            return false;

        Tuple<int, int> reference = nodes[nodeId].GetReference();
        bool notInstanced = LoadedData.GetVariableType(subclassTypes[nodeId], variableId, VariableTypes.NON_INSTANCED);

        // Returns null if this is the root.

        //Debug.Log("Ref: " + reference);
        if(notInstanced || reference == null || (reference.Item1 == centralId && reference.Item2 == nodeId))
            return false;

        return true;
    }

    public AbilityCentralThreadPool GetRootReferenceCentral(int nodeId) {
        Tuple<int, int> reference = nodes[nodeId].GetReference();
        return globalCentralList.l[reference.Item1];
    }

    public AbilityTreeNode GetRootReferenceNode(int nodeId) {

        if(nodes[nodeId] == null)
            return null;

        Tuple<int, int> reference = nodes[nodeId].GetReference();
        return GetRootReferenceCentral(nodeId).GetNode(reference.Item2);
    }

    public NETWORK_CLIENT_ELIGIBILITY CheckEligibility(int nodeId, int variableId) {

        if(LoadedData.GetVariableType(subclassTypes[nodeId], variableId, VariableTypes.CLIENT_ACTIVATED)) {
            if(playerCasted != ClientProgram.clientId)
                return NETWORK_CLIENT_ELIGIBILITY.DENIED;
            else
                return NETWORK_CLIENT_ELIGIBILITY.GRANTED;
        }

        if(LoadedData.GetVariableType(subclassTypes[nodeId], variableId, VariableTypes.HOST_ACTIVATED))
            if(ClientProgram.hostId != ClientProgram.clientId)
                return NETWORK_CLIENT_ELIGIBILITY.DENIED;
            else
                return NETWORK_CLIENT_ELIGIBILITY.GRANTED;

        return NETWORK_CLIENT_ELIGIBILITY.LOCAL_HOST;
    }

    public void UpdateVariableValue<T>(int nodeId, int variableId, T value, bool runValueChanged = true) {

        bool reference = CheckIfReferenced(nodeId, variableId);

        // If reference is not empty, redirects it to change that variable instead.
        if(reference) {
            Tuple<int, int> refLink = nodes[nodeId].GetReference();

            //Debug.LogFormat("Var set, central {0}, node {1}, var {2}, value {3}", refLink.Item1, refLink.Item2, variableId, value);
            GetRootReferenceCentral(nodeId).UpdateVariableValue<T>(refLink.Item2, variableId, value, runValueChanged);
            return;
        }

        RuntimeParameters<T> paramInst = runtimeParameters[nodeId][variableId].field as RuntimeParameters<T>;
        T[] valuePair = new T[2];

        if(paramInst != null) {
            valuePair[0] = paramInst.v;
            valuePair[1] = value;

            paramInst.v = value;
        } else if(LoadedData.GetVariableType(subclassTypes[nodeId], variableId, VariableTypes.INTERCHANGEABLE)) {
            string varName = runtimeParameters[nodeId][variableId].field.n;
            int[][] links = runtimeParameters[nodeId][variableId].links;

            //Debug.LogFormat("Var changed from {0} to {1}", runtimeParameters[nodeId][variableId].field.t, typeof(T));
            runtimeParameters[nodeId][variableId] = new Variable(new RuntimeParameters<T>(varName, value), links);

            valuePair[0] = value;
            valuePair[1] = value;
        } else
            runValueChanged = false;

        // Does run value stuff here.
        if(runValueChanged) {
            // Needs rework.
            Tuple<int, int> id = Tuple.Create<int, int>(nodeId, variableId);

            //Debug.Log(nodeId);
            //Debug.Log(variableId);

            if(onChanged.ContainsKey(id)) {

                foreach(var changeCallback in onChanged[id]) {
                    //Debug.Log(changeCallback.Item1);
                    //Debug.Log(changeCallback.Item2);
                    //Debug.LogFormat("Routing to variable on change central {0}, node {1}", changeCallback.Item1, changeCallback.Item2);
                    OnValueChange valChangeNode = globalCentralList.l[changeCallback.Item1].GetNode(changeCallback.Item2) as OnValueChange;
                    valChangeNode.HandleSettingOnChange<T>(valuePair, new int[] { centralId, nodeId, variableId });
                }

                onChanged.Remove(id);
            }
        }
    }

    public void NodeVariableCallback<T>(int threadId, int variableId) {

        if(threadId == -1)
            return;

        int currNode = activeThreads.l[threadId].GetCurrentNodeID();
        NETWORK_CLIENT_ELIGIBILITY nCE = CheckEligibility(currNode, variableId);

        //Debug.Log(nCE);

        switch(nCE) {
            case NETWORK_CLIENT_ELIGIBILITY.GRANTED:
                RuntimeParameters<T> paramInst = runtimeParameters[currNode][variableId].field as RuntimeParameters<T>;
                AddVariableNetworkData(new AbilityNodeNetworkData<T>(currNode, variableId, paramInst.v));
                break;
            case NETWORK_CLIENT_ELIGIBILITY.DENIED:
                return;
        }

        UpdateVariableData<T>(threadId, variableId);
    }

    public void UpdateVariableData<T>(int threadId, int variableId, RuntimeParameters<T> var = null, bool runOnCalled = true) {

        if(threadId == -1)
            return;



        int currNode = activeThreads.l[threadId].GetCurrentNodeID();
        int[][] links = runtimeParameters[currNode][variableId].links;
        int currPossiblePaths = activeThreads.l[threadId].GetPossiblePaths();

        if(var == null)
            var = ReturnRuntimeParameter<T>(currNode, variableId);
        //Debug.LogFormat("Central ID: {0}, Node Id: {1}, Variable ID: {2}, Value {3}", centralId, currNode, variableId, var.v);

        //Debug.LogFormat("Thread: {0}, CurrNode to be Set: {1}", threadId, currNode);

        for(int i = 0; i < links.Length; i++) {

            int nodeId = links[i][0];
            int nodeVariableId = links[i][1];
            int linkType = links[i][2];
            int threadIdToUse = threadId;

            if(runOnCalled) {

                int totalOnCalled = RunTargettedNodes<T>(nodeId, nodeVariableId, typeof(OnVariableCalled), var.v);

                if(totalOnCalled > 0)
                    continue;
            }

            NodeThread newThread = activeThreads.l[threadId].CreateNewThread();

            //Debug.LogFormat("Current info: CurrNode{0}, CurrVar{1}, CurrLink{2}, CurrLinkLen{3}",currNode,variableId,i,links[i].Length);


            if(newThread != null) {
                threadIdToUse = activeThreads.Add(newThread);
                //newThread.SetSources(currNode,vSource);
                //Debug.LogFormat("{0} has been spawned by {1}, ischild: {2}", threadIdToUse, threadId, activeThreads.l[threadId] is ChildThread);

            } else {
                //If no creation needed, means its the last.
                //int node = activeThreads.l[threadId].GetCurrentNodeID();
                AbilityTreeNode currNodeInst = CreateNewNodeIfNull(currNode);

                // Checks if the original thread is equal to the NTID to make sure we only set the thread id once to default.
                if(currNodeInst.GetNodeThreadId() == threadId)
                    currNodeInst.SetNodeThreadId(-1);

                //activeThreads.l[threadId].SetSources(currNode,vSource);
            }

            activeThreads.l[threadIdToUse].SetNodeData(nodeId, nodeBranchingData[nodeId]);


            switch((LinkMode)linkType) {
                case LinkMode.NORMAL:
                    //Debug.Log(originalParamInst.v);
                    booleanData[nodeId][nodeVariableId] = false;
                    UpdateVariableValue<T>(nodeId, nodeVariableId, var.v);
                    break;
            }


            AbilityTreeNode nextNodeInst = CreateNewNodeIfNull(nodeId);

            int existingThread = nextNodeInst.GetNodeThreadId();

            if(existingThread > -1) {
                //Debug.Log("Remove existing thread: " + existingThread);
                HandleThreadRemoval(existingThread);
                //activeThreads.l[threadIdToUse](existingThread);
            }

            nextNodeInst.SetNodeThreadId(threadIdToUse);

            //Debug.Log("Before node callback:" + GetRootReferenceNode(nodeId));
            if(CheckIfReferenced(nodeId, nodeVariableId))
                GetRootReferenceNode(nodeId).NodeCallback();
            else
                nextNodeInst.NodeCallback();

            // Automatically callback all auto managed nodes.
            for(int j = 0; j < autoManagedVar[nodeId].Length; j++)

                // Callback those that are not blocked.
                if(!booleanData[nodeId][autoManagedVar[nodeId][j]])
                    runtimeParameters[nodeId][autoManagedVar[nodeId][j]].field.RunGenericBasedOnRP<int[]>(this, new int[] { nodeId, autoManagedVar[nodeId][j] });


            // Checks if node has no more output

            //Debug.Log(nodeBranchingData[nodeId]);
            //if(nodeBranchingData[nodeId] == 0) {

            //HandleThreadRemoval(threadIdToUse);
            //}
        }




        //if(jointThreadId > -1)
        //UpdateVariableData<T>(jointThreadId, variableId);

        // All these exist outside of thread removal and handling. Need to move it somewhere else.


        // Updates the other instances.
        if(sharedInstance.ContainsKey(currNode))
            foreach(var inst in sharedInstance[currNode]) {
                //Debug.LogFormat("Central {0} Node {1} is a instance to be set.", inst.Item1, inst.Item2);
                AbilityCentralThreadPool centralInst = globalCentralList.l[inst.Item1];

                //Debug.LogFormat("pregame Central ID: {0}, Node Id: {1}, Variable ID: {2}, Value {3}, Type{4}", inst.Item1, inst.Item2, variableId, var.v, typeof(T));
                //Debug.Log("Thread ID" + centralInst.GetNode(inst.Item2).GetNodeThreadId());
                centralInst.UpdateVariableData<T>(centralInst.GetNode(inst.Item2).GetNodeThreadId(), variableId, var);
            }


        //Debug.LogFormat("Thread: {0}, CurrNode to be Set: {1}", threadId, currNode);
        //Debug.Log("Curr Possible Paths: " + currPossiblePaths);

        if(currPossiblePaths == 0) {
            //Debug.Log("Caused end #0");
            HandleThreadRemoval(threadId);
        }
    }

    public int RunTargettedNodes<T>(int node, int variable, Type catergory, T value) {
        int targetInCatergory = 0;

        if(sharedInstance.ContainsKey(node))
            foreach(var id in sharedInstance[node]) {
                AbilityCentralThreadPool centralInst = globalCentralList.l[id.Item1];
                Tuple<int, int> tNId = Tuple.Create<int, int>(id.Item2, variable);
                
                if(centralInst.targettedNodes.ContainsKey(tNId) && centralInst.targettedNodes[tNId].ContainsKey(catergory)) {
                    targetInCatergory += centralInst.targettedNodes[tNId][catergory].Count;

                    foreach(int nodeId in centralInst.targettedNodes[tNId][catergory]) {
                        OnVariableCalled nodeInst = globalCentralList.l[id.Item1].GetNode(nodeId) as OnVariableCalled;
                        nodeInst.OnVariableCalledCallback<T>(value, id.Item2, variable);
                    }
                }
            }

        Tuple<int, int> sIDS = Tuple.Create(node, variable);

        if(targettedNodes.ContainsKey(sIDS) && targettedNodes[sIDS].ContainsKey(catergory)) {

            targetInCatergory += targettedNodes[sIDS][catergory].Count;

            foreach(int oVCNode in targettedNodes[sIDS][catergory]) {
                OnVariableCalled oVCInst = CreateNewNodeIfNull(oVCNode) as OnVariableCalled;
                oVCInst.OnVariableCalledCallback<T>(value, node, variable);
            }
        }

        return targetInCatergory;
    }


    public void HandleThreadRemoval(int threadId) {

        //Debug.LogFormat("Thread {0} has ended operations.", threadId);
        // Callback to start node.

        //Debug.Log(threadId);
        //Debug.Log(activeThreads.l[threadId].GetCurrentNodeID() + " / " + (nodes.Length-1));
        CreateNewNodeIfNull(activeThreads.l[threadId].GetCurrentNodeID()).SetNodeThreadId(-1);
        CreateNewNodeIfNull(activeThreads.l[threadId].GetStartingPoint()).ThreadEndStartCallback(threadId);

        // Removes that thread.
        activeThreads.Remove(threadId);

        //Debug.LogFormat("{0} threadIdRemoved, 1st Element: {1}", threadId, activeThreads.ReturnActiveElementIndex()[0]);

        //if(activeThreads.GetActiveElementsLength() == 0)
        //Debug.Log("All thread operations has ended.");
    }

    public AbilityTreeNode CreateNewNodeIfNull(int nodeId) {

        if(!nodes[nodeId]) {

            // Tries to convert type into a singleton to see if it exist.
            if(LoadedData.singletonList.ContainsKey(subclassTypes[nodeId]))
                nodes[nodeId] = LoadedData.singletonList[subclassTypes[nodeId]] as AbilityTreeNode;

            if(nodes[nodeId] == null) {
                SpawnerOutput sOInst = LoadedData.GetSingleton<Spawner>().CreateScriptedObject(subclassTypes[nodeId]);
                nodes[nodeId] = sOInst.script as AbilityTreeNode;
                nodes[nodeId].SetSourceObject(sOInst);

                // Changes its name
                nodes[nodeId].name = networkObjectId.ToString() + '/' + nodeId.ToString();

                // Adds it to root
                nodes[nodeId].transform.SetParent(abilityNodeRoot);
            }

            AbilityTreeNode inst = nodes[nodeId];

            inst.SetNodeThreadId(-1);
            inst.SetNodeId(nodeId);
            inst.SetCentralId(centralId);
            return inst;
        }

        return nodes[nodeId];
    }

    public void RenameAllNodes() {
        for(int i = 0; i < nodes.Length; i++)
            if(nodes[i] != null)
                nodes[i].name = networkObjectId.ToString() + '/' + i.ToString();
    }


    // This should be ran with curr node rather than thread.
    public void RunAccordingToGeneric<T, P>(P arg) {
        int[] nodeCBInfo = (int[])(object)arg;

        AbilityTreeNode inst = CreateNewNodeIfNull(nodeCBInfo[0]);
        NodeVariableCallback<T>(inst.GetNodeThreadId(), nodeCBInfo[1]);
    }
}
